Tyler Filla
CS 4760
Assignment 6

Preamble
========

Since the simulated processes don't have a page table register (research), I map the processes' pids to page tables in
a shared memory array.

User mode reads and writes are coarsely simulated. There is no data read/written, but a type called ptr_vm_t is used to
"point to" a location in simulated virtual memory.

Since no scheduling is simulated, oss really has no control over the children, so suspension is simulated in the
children when memmgr informs them of page faults.

There is no queue structure for the mythical memory backing store device. Instead, since each process can only wait on
one page at a time, a single array with MAX_USER_PROCS of wait buffers is used. Each wait buffer identifies the waiting
process and the time at which its simulated wait is lifted. oss lifts the waits every now and then based on the clock.

Due to the corners cut for the simulation, I found it most efficient to let child processes advance the clock by 10ns
themselves when they read/write. The reads/writes are already simulated partially in oss and partially in child, so this
is not too much of a problem in my book.

As a side-effect of shared memory (abs. pointers within it not practical), I have to types of page number: VM page
number and system page number. NOTE: Define them individually.

Directory Structure
===================

Project Root
 |
 +-- child.c        (the main file for the child program)
 |
 +-- clock.c        (the main file for the clock library)
 |
 +-- clock.h        (the corresponding header file for clock.c)
 |
 +-- config.h       (a header file with global configuration settings)
 |
 +-- logger.c       (the main file for the logger library)
 |
 +-- logger.h       (the corresponding header file for logger.c)
 |
 +-- Makefile
 |
 +-- oss.c          (the main file for the oss program)
 |
 +-- memmgr.c       (the main file for the memory manager library)
 |
 +-- memmgr.h       (the corresponding header file for memmgr.c)
 |
 +-- README

Building
========

To build, run the following command:

$ make

Usage
=====

At any time, run the following command for help:

$ ./oss -h

The program will run with the assigned defaults if you run the following:

$ ./oss

To run in verbose mode to see what is happening internally, use -v:

$ ./oss -v

Interrupt the process with ^C on a terminal to stop the simulation.

Cleanup
=======

To clean up after a build, use the following command:

$ make clean
